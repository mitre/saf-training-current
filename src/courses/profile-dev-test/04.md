---
order: 4
next: 05.md
title: Test your Test Environment
author: Aaron Lippold
---

# Getting to know the Testing Suite

Once you've set up the necessary tools, you're ready to run the profile. The testing environment is determined by Test Kitchen using environment variables.

There are four testing environments to choose from:

1. AWS VPC Testing: This environment uses an AWS VPC for testing.
2. Docker Testing: This environment uses Docker containers for testing.
3. Vagrant Testing: This environment uses Vagrant virtual machines for testing.
4. Local Testing: This environment uses your local machine for testing.

The specifics of each environment's configuration are detailed in the following sections.

# Getting Your First Test Kitchen (TK) Run

For each of these examples, you need to update the `KITCHEN_LOCAL_YAML` environment variable to point to the correct `kitchen.<TEST-TARGET>.yaml` file. Ensure that any required supporting environment settings, environment variables, profiles, etc., are in place. See Environment Variables and Testing Target Environments for more information.

Learn more about the Test Kitchen project at: [kitchen.ci](https://kitchen.ci/ "Test Kitchen Project Homepage")

## Kitchen Stages

Test Kitchen has four major steps: `create`, `converge`, `verify`, and `destroy`. Use these stages to create, configure, run tests, and destroy your testing target. When starting your testing, it's useful to run each of these in turn to ensure your environment, Test Kitchen, and credentials are set up and working correctly.

1. `create`:
  The `create` stage sets up your testing instance and prepares the necessary login credentials and other components so you can use your testing target.
2. `converge`:
  The `converge` stage runs the provisioner of the Test Kitchen suite - the configuration management code set up in the test suite. This could be any configuration management script, such as Ansible, Chef, Puppet, Terraform, Shell, etc., that you and your team use.
3. `verify`:
  The `verify` stage runs the actual InSpec profile against your testing target. Test Kitchen supports multiple testing frameworks, which are well documented on the project website.
4. `destroy`:
  The `destroy` stage tears down your test target - like an EC2 instance, Docker container, or Vagrant Box.

During your testing, you will use each of these steps to run the full profile, run individual controls (using the `INSPEC_CONTROL` environment variable), and manage your test instances. You will also use other Test Kitchen commands, such as `login`, `test`, and others, which are documented on the [Test Kitchen Project](https://kitchen.ci "Test Kitchen Project Homepage") page.

You can also isolate which of the 'target suites' - either `vanilla` or `hardened` in our case - to run by appending either `hardened` or `vanilla` to the end of your Test Kitchen command. For example, `bundle exec kitchen verify` will run the Test Kitchen stages all the way through `verify` on _both_ the `hardened` and `vanilla` suites. However, if you say, `bundle exec kitchen verify vanilla`, it will only run it on the `vanilla` test target.

# Useful Test Kitchen Commands

- `login`: Allows you to easily log in using the credentials created when you ran `bundle exec kitchen create`.
- `test`: Runs all the Test Kitchen stages starting with create through destroy to easily allow you to go through a full clean test run.

# Converge

For RHEL8, we use Ansible as our `provisioner`, which handles configuring the test target during the `kitchen converge` step. We use the `suites` attribute alongside `provisioner` to define what test targets we want to create and how to configure them:

Let's take a quick look at the `provisioner` section:
``` yaml
provisioner:
  name: ansible_playbook
  hosts: all
  require_chef_for_busser: false
  require_ruby_for_busser: false
  ansible_binary_path: /usr/local/bin
  # require_pip3: true
  ansible_verbose: true
  roles_path: spec/ansible/roles
  galaxy_ignore_certs: true
  requirements_path: spec/ansible/roles/requirements.yml
  requirements_collection_path: spec/ansible/roles/requirements.yml
  ansible_extra_flags: <%= ENV['ANSIBLE_EXTRA_FLAGS'] %>

suites:
  - name: vanilla
    provisioner:
      playbook: spec/ansible/roles/ansible-role-rhel-vanilla.yml
    driver:
      tags:
        Name: Vanilla-<%= ENV['USER'] %>
        CreatedBy: test-kitchen

  - name: hardened
    provisioner:
      playbook: spec/ansible/roles/ansible-role-rhel-hardened.yml
    driver:
      tags:
        Name: Hardened-<%= ENV['USER'] %>
        CreatedBy: test-kitchen
```

There are quite a few variables set here to make Ansible run correctly, but the really important ones are:
- `name: ansible_playbook`, which informs Kitchen that we are using Ansible in the first place, and
- `roles_path: spec/ansible/roles`, which tells Ansible where the roles we want to use on our target will live.

Meanwhile, in `suites`, we invoke the `provisioner` attribute again to add one more line to the `provisioner` data for each individual item in the suite. We tell Kitchen that the playbook for the `hardened` test target lives in `spec/ansible/roles/ansible-role-rhel-hardened.yml`, and the `vanilla` playbook lives in `spec/ansible/roles/ansible-role-rhel-vanilla.yml`.

## The `spec` folder

By convention, we drop off all of our configuration management artifacts, including our Ansible content, in the `spec` directory inside the profile (this folder is for defining the 'specification' we want our test suite to meet).

If we look inside `spec/ansible/roles`, we see that we have a role for both of the hardened and vanilla test targets we want. We also see a `requirements.yml` file, which defines extra content outside of the `spec` directory we will be referencing in these roles (we also told Kitchen about these dependencies using `requirements_path: spec/ansible/roles/requirements.yml`).

That `requirements.yml` file includes a dependency for a piece of code in the MITRE SAF [Hardening Library](https://saf.mitre.org/libs/harden):

``` yaml
roles:
  - name: rhel8STIG
    src: https://github.com/ansible-lockdown/RHEL8-STIG
```

### The Playbooks

The `ansible-role-rhel-vanilla.yml` file in the `spec/ansible/roles` directory describes what role we want run against our vanilla target:

``` yaml
---
- hosts:
    - localhost
  roles:
    - roles/ansible-role-rhel-vanilla
  serial: 50
```

It's a pretty short playbook. All we really want to do is run a single role that we have written specifically for the vanilla test target. If you're curious, all that particular role really does is run a quick `yum update` to ensure that our test target is nice and up to date.

::: tip
Remember that the whole point of a vanilla test target is to see what happens when we run our profile against a target that is fresh out of the box. That's why we aren't doing anything to it besides a quick package update.
:::

The `ansible-role-rhel-hardened.yml` file, meanwhile, references that dependency from the `requirements.yml` file:

``` yaml
---
- hosts:
    - localhost
  roles:
    - roles/ansible-role-rhel-vanilla
    - roles/rhel8STIG
  serial: 50
  become: yes
  vars:
    rhel8stig_bootloader_password_hash: "changethispassword"
    rhel_08_040123: false # RHEL 8 must mount /tmp with the nodev option.
    rhel_08_040124: false # RHEL 8 must mount /tmp with the nosuid option.
    rhel_08_040125: false # RHEL 8 must mount /tmp with the noexec option.
    rhel_08_010380: false # RHEL 8 must require users to provide a password for privilege escalation.
```

Note that actually run two roles here: the local `vanilla` role, which runs a quick `yum update`, and then the STIG-hardening code from the MITRE SAF Hardening Library.

So, ultimately, we have:
- told Kitchen to invoke Ansible
- told Ansible to look in the `spec` folder for a playbook on how to configure each test target
- told the playbook to go grab already-written hardening content from the Hardening Library for the `hardened` target

Kitchen and Ansible can thus work together to converge both test targets to their desired state.